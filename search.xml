<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[d3力导向图，Zoom后brush画刷选取node节点不正常]]></title>
    <url>%2F2018%2F11%2F26%2Fd3%E5%8A%9B%E5%AF%BC%E5%90%91%E5%9B%BE%EF%BC%8CZoom%E5%90%8Ebrush%E7%94%BB%E5%88%B7%E9%80%89%E5%8F%96node%E8%8A%82%E7%82%B9%E4%B8%8D%E6%AD%A3%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[在用brush画刷批量选取力学导图的node节点时，页面初始化时是一切正常的。 但是点击zoom事件放大缩小后，brush画刷选取开始出现明显的不正常，有时候可以选取到，有时候选取不到。 正常情况： zoom后： 这是我初始化brush的代码： 这是zoom的代码 //set zoomfunction setZoom() { $(‘#zoomOut’).click(function () { if (scale &lt; 5) { scale = scale + 0.1; //增加比例尺 gTranslateAndScale(scale); zoomType = “out”; } $(this).blur(); }); $(&apos;#zoomIn&apos;).click(function () { if (scale &gt;= 0.2) { scale = scale - 0.1; gTranslateAndScale(scale); zoomType = &quot;in&quot;; } $(this).blur(); }); } //translate and scalefunction gTranslateAndScale(scale) { g.attr(“transform”, “translate(“ + (width (1 - scale)) / 2 + “,” + ($(“svg”).height() (1 - scale)) / 2 + “)scale(“ + scale + “)”);} 原因是：zoom之后元素坐标系发生变化，brush的坐标系和zoom对不上了。 brush的坐标和zoom的坐标是不在一个平面内的。 transform=”translate(-57.45000000000005,-20.10000000000002)scale(1.1)” translate(x,y) // 定义 2D 转换。 向左移动57，向上移动27 scale // 放大1.1 解决办法：zoom 之后他们在两套坐标系统内，那么只能把一个坐标转化到另一个系统中 相同坐标系下做对比。zoom后，在brush的extent判断落点里把extent的x,y也相对的放大，判断当前node的落点是否在extent区域内 重点是：在一个坐标系变换后，要统计两个坐标系的判断标准。 最终解决代码如下： zoom代码： //translate and scale/** transform=”translate(-57.45000000000005,-20.10000000000002)scale(1.1)”* translate(x,y) 定义 2D 转换。 向左移动57，向上移动27* scale 放大1.1* /function gTranslateAndScale(scale) { translate_a = (width (1 - scale)) / 2; translate_b = ($(“svg”).height() (1 - scale)) / 2; g.attr(“transform”, “translate(“ + (width (1 - scale)) / 2 + “,” + ($(“svg”).height() * (1 - scale)) / 2 + “)scale(“ + scale + “)”);} brush代码： var brush = svg.append(“g”) .datum(function() { return {selected: false, previouslySelected: false}; }) .attr(“class”, “brush”) .call(d3.svg.brush() .x(d3.scale.identity().domain([0, width])) .y(d3.scale.identity().domain([0, height])) .on(“brushstart”, function(d) { nodes.each(function(d) { d.previouslySelected = shiftKey &amp;&amp; d.selected; }); }) .on(“brush”, function() { var extent = d3.event.target.extent(); nodes.classed(&quot;selected&quot;, function(d) { if( zoomType == &quot;out&quot; || zoomType == &quot;in&quot;){ console.log(&quot;重新设置了brush的extent&quot;); /* 警告zoom放大或者缩小后，&lt;g class=&quot;nodes&quot; transform=&quot;translate(170.29999999999995,76.29999999999998)scale(0.8)&quot; nodes的坐标系发生了变化。由于nodes和brush不在一个坐标系 nodes坐标系变化，brush的extent\[画刷的点击框选范围\]也要随之变化，这样才能正确判断node是否在extent范围内 \* */ return d.selected = d.previouslySelected ^ (((extent\[0\]\[0\]-translate\_a)/scale) &lt;= d.x &amp;&amp; d.x &lt; ((extent\[1\]\[0\]-translate\_a)/scale) &amp;&amp; ((extent\[0\]\[1\]-translate\_b)/scale) &lt;= d.y &amp;&amp; d.y &lt; ((extent\[1\]\[1\]-translate\_b)/scale) ); } else{ console.log(&quot;没有重新设置extent&quot;); return d.selected = d.previouslySelected ^ (extent\[0\]\[0\] &lt;= d.x &amp;&amp; d.x &lt; extent\[1\]\[0\] &amp;&amp; extent\[0\]\[1\] &lt;= d.y &amp;&amp; d.y &lt; extent\[1\]\[1\]); } }); }) .on(&quot;brushend&quot;, function() { d3.event.target.clear(); d3.select(this).call(d3.event.target); }));]]></content>
  </entry>
  <entry>
    <title><![CDATA[SVG学习笔记]]></title>
    <url>%2F2018%2F11%2F26%2FSVG%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习svg主要参考了w3c的教程： http://www.w3school.com.cn/svg/index.asp 什么是SVG？ SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 SVG 形状SVG 有一些预定义的形状元素，可被开发者使用和操作：（这里只学习项目用到的） 矩形 圆形 椭圆 线 折线 多边形 路径 1、 标签可用来创建一个圆。 &lt;?xml version=”1.0” standalone=”no”?&gt;&lt;!DOCTYPE svg PUBLIC “-//W3C//DTD SVG 1.1//EN”“http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值） CSS 的 stroke-width 属性定义矩形边框的宽度 CSS 的 stroke 属性定义矩形边框的颜色 cx 和 cy 属性定义圆点的 x 和 y 坐标。如果省略 cx 和 cy，圆的中心会被设置为 (0, 0) r 属性定义圆的半径。 2、 标签用来创建线条。 x1 属性在 x 轴定义线条的开始 y1 属性在 y 轴定义线条的开始 x2 属性在 x 轴定义线条的结束 y2 属性在 y 轴定义线条的结束 3、 标签用来定义路径。 下面的命令可用于路径数据： M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Belzier curve T = smooth quadratic Belzier curveto A = elliptical Arc Z = closepath 注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。 上面的例子定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径。查看效果：http://www.w3school.com.cn/svg/path1.svg下面的例子创建了一个螺旋： 查看演示：http://www.w3school.com.cn/svg/path2.svg d3.js——箭头的绘制：http://www.2cto.com/kf/201605/507470.html 箭头绘制要注意的概念 核心代码： //添加defs标签 var defs = svg.append(“defs”);//添加marker标签及其属性 var arrowMarker = defs.append(“marker”) .attr(“id”,”arrow”) .attr(“markerUnits”,”strokeWidth”) .attr(“markerWidth”,12) .attr(“markerHeight”,12) .attr(“viewBox”,”0 0 12 12”) .attr(“refX”,6) .attr(“refY”,6) .attr(“orient”,”auto”)//绘制直线箭头 var arrow_path = “M2,2 L10,6 L2,10 L6,6 L2,2”; arrowMarker.append(“path”) .attr(“d”,arrow_path) .attr(“fill”,”#000”)//绘制直线 var line = svg.append(“line”) .attr(“x1”,50) .attr(“y1”,50) .attr(“x2”,200) .attr(“y2”,400) .attr(“stroke”,”red”) .attr(“stroke-width”,2) .attr(“marker-start”,”url(#arrow)”) .attr(“marker-end”,”url(#arrow)”) 更多实例演示：http://www.w3school.com.cn/svg/svg_examples.asp]]></content>
  </entry>
  <entry>
    <title><![CDATA[WARNING: Max 1024 open files allowed, minimum of 40000 recommended. See the Neo4j manua]]></title>
    <url>%2F2018%2F11%2F26%2FWARNING-Max-1024-open-files-allowed-minimum-of-40000-recommended-See-the-Neo4j-manua%2F</url>
    <content type="text"><![CDATA[When you restart your service you’ll notice this warning: WARNING: Max 1024 open files allowed, minimum of 40 000 recommended. See the Neo4j manual. To fix this, edit this file sudo nano /etc/security/limits.conf and add these two entries: root soft nofile 40000root hard nofile 40000neo4j soft nofile 40000neo4j hard nofile 40000panos soft nofile 40000panos hard nofile 40000 I add an entry for all three users root, neo4j and panos, but you actually just need the one that you’ll use when you restart the service. Then edit sudo nano /etc/pam.d/su uncomment this line session required pam_limits.so and restart your server (your machine not the service). //改完要重启机器 Now if you do sudo service neo4j-service restart the warning should have disappeared.]]></content>
  </entry>
  <entry>
    <title><![CDATA[neo4j批量数据导入]]></title>
    <url>%2F2018%2F11%2F26%2Fneo4j%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[首先把我的参考资料列出来： 官方load 指南： https://neo4j.com/developer/guide-import-csv/ load csv官方手册：https://neo4j.com/docs/developer-manual/3.2-alpha/cypher/clauses/load-csv/ 使用neo4j web管理端导入CSV：http://blog.csdn.net/qq_23318779/article/details/66970960 如何将大规模数据导入Neo4j：http://paradoxlife.me/how-to-insert-bulk-data-into-neo4j 数据库运行实时导入–选择load csv模式 csv文件： 1234567name,Operator,CountR,Zone,phonenumber,Country,Count,Span,SpanR1000004,unkonwn,413,unkonwn,1000004,hefei,5573,9678,116881000005,unkonwn,413,unkonwn,1000005,hefei,5573,9678,116881000006,unkonwn,413,unkonwn,1000006,hefei,5573,9678,116881000007,unkonwn,413,unkonwn,1000007,hefei,5573,9678,116881000008,unkonwn,413,unkonwn,1000008,hefei,5573,9678,116881000009,unkonwn,413,unkonwn,1000009,hefei,5573,9678,11688 导入写法： 12345678910111213//基本LOAD CSV WITH HEADERS FROM &quot;file:///writers.csv&quot; AS line return line.name,line.Operator,line.CountR,line.Zone,line.phonenumber,line.Country,line.Count,line.Span,line.SpanR//实际使用的load csvUSING PERIODIC COMMIT 1000 //使用自动提交，每满300条提交一次，防止内存溢出LOAD CSV WITH HEADERS FROM &quot;file:///writers.csv&quot; AS line MERGE(a:User&#123;name:line.name,Operator:line.Operator,CountR:line.CountR,Zone:line.Zone,phonenumber:line.phonenumber,Country:line.Country,Count:line.Count,Span:line.Span,SpanR:line.SpanR&#125;) //改进 实际使用的load csv //可用toInt()等方法 USING PERIODIC COMMIT 300 LOAD CSV WITH HEADERS FROM &quot;file:///writers.csv&quot; AS line MERGE(a:User&#123;name:toInt(line.name),Operator:line.Operator,CountR:line.CountR,Zone:line.Zone,phonenumber:toInt(line.phonenumber),Country:line.Country,Count:line.Count,Span:line.Span,SpanR:line.SpanR&#125;) 注意事项：writers.csv文件要放在数据库的import目录下，如果windows环境下没有import目录，需要手动创建该目录。 数据库初始化海量数据导入：neo4j-import csv文件： 1234567891011//nodes5000w.csv 注意ID LABELuserID:ID,name:int,Operator,CountR:int,Zone,phonenumber:int,Country,Count:int,Span:int,SpanR:int,:LABEL1,1,unkonwn,413,unkonwn,1,hefei,5573,9678,11688,User2,2,unkonwn,413,unkonwn,2,hefei,5573,9678,11688,User3,3,unkonwn,413,unkonwn,3,hefei,5573,9678,11688,User//rel5e.csv 注意:START_ID,:END_ID,:TYPE（关系名） 其它为属性:START_ID,weekday,BeginTime,calltype,span,:END_ID,:TYPE46589503,Sunday,1970/01/01 00:00:00,VOICE,73,27631982,VOICE35873539,Sunday,1970/01/01 00:00:00,FAX,73,28585489,FAX38370591,Sunday,1970/01/01 00:00:00,FAX,73,8746151,FAX 12//导入命令./neo4j-import --into /data/neo4j/databases/graph10.db/ --nodes /home/iflytek/data/nodes5000w.csv --relationships /home/iflytek/data/rel5e.csv 导入结果： 使用batch-import工具向neo4j中导入海量数据：（详细教程） https://my.oschina.net/u/2538940/blog/883829]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 软件安装到 /usr，/usr/local/ 还是 /opt 目录？]]></title>
    <url>%2F2018%2F11%2F26%2FLinux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%88%B0-usr%EF%BC%8C-usr-local-%E8%BF%98%E6%98%AF-opt-%E7%9B%AE%E5%BD%95%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Linux 的软件安装目录是也是有讲究的，理解这一点，在对系统管理是有益的 /usr：系统级的目录，可以理解为C:/Windows/，/usr/lib理解为C:/Windows/System32。/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。/opt：用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。 源码放哪里？/usr/src：系统级的源码目录。/usr/local/src：用户级的源码目录。 —————–翻译——————- /opt Here’s where optional stuff is put. Trying out the latest Firefox beta? Install it to /opt where you can delete it without affecting other settings. Programs in here usually live inside a single folder whick contains all of their data, libraries, etc.这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。 /usr/local This is where most manually installed(ie. outside of your package manager) software goes. It has the same structure as /usr. It is a good idea to leave /usr to your package manager and put any custom scripts and things into /usr/local, since nothing important normally lives in /usr/local. 这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。]]></content>
  </entry>
  <entry>
    <title><![CDATA[neo4j配置文件注意项]]></title>
    <url>%2F2018%2F11%2F26%2Fneo4j%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B3%A8%E6%84%8F%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 8 # The name of the database to mount 9 dbms.active_database=graph10.db //数据库名 10 #dbms.active_database=graph.db //默认注释 11 12 # Paths of directories in the installation. 13 dbms.directories.data=/data/neo4j //数据库存储地址 14 #dbms.directories.data=data //默认注释 在neo4j安装目录下的data下 20 # This setting constrains all `LOAD CSV` import files to be under the `import` directory. Remove or comment it out to 21 # allow files to be loaded from anywhere in the filesystem; this introduces possible security problems. See the 22 # `LOAD CSV` section of the manual for details. 23 #dbms.directories.import=import //注释该行，导入csv文件可在系统任意目录下 neo4j-import时用 36 #dbms.memory.heap.initial_size=2048m 37 #dbms.memory.heap.max_size=512m 38 dbms.memory.heap.initial_size=30720m //初始内存 我设置为除系统用4G后的所有 39 dbms.memory.heap.max_size=30720m# The amount of memory to use for mapping the store files, in bytes (or 42 # kilobytes with the &apos;k&apos; suffix, megabytes with &apos;m&apos; and gigabytes with &apos;g&apos;). 43 # If Neo4j is running on a dedicated server, then it is generally recommended 44 # to leave about 2-4 gigabytes for the operating system, give the JVM enough 45 # heap to hold all your transaction state and query context, and then leave the 46 # rest for the page cache. 47 # The default page cache memory assumes the machine is dedicated to running 48 # Neo4j, and is heuristically set to 50% of RAM minus the max Java heap size. 49 dbms.memory.pagecache.size=32g //内存 我设置为除系统用4g后的所有 61 # With default configuration Neo4j only accepts local connections. 62 # To accept non-local connections, uncomment this line: 63 dbms.connectors.default_listen_address=0.0.0.0 //打开远程访问//HA模式配置239 # Database mode240 # Allowed values:241 # HA - High Availability242 # SINGLE - Single mode, default.243 # To run in High Availability mode uncomment this line:244 dbms.mode=HA245 246 # ha.server_id is the number of each instance in the HA cluster. It should be247 # an integer (e.g. 1), and should be unique for each cluster instance.248 ha.server_id=1249 250 # ha.initial_hosts is a comma-separated list (without spaces) of the host:port251 # where the ha.host.coordination of all instances will be listening. Typically252 # this will be the same for all cluster instances.253 ha.initial_hosts=10.1.140.25:5001,10.1.140.24:5001 //此处比较重要]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssm web项目JVM关闭钩子未生效；使用spring容器启动事件和关闭事件。]]></title>
    <url>%2F2018%2F11%2F26%2Fssm-web%E9%A1%B9%E7%9B%AEJVM%E5%85%B3%E9%97%AD%E9%92%A9%E5%AD%90%E6%9C%AA%E7%94%9F%E6%95%88%EF%BC%9B%E4%BD%BF%E7%94%A8spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%85%B3%E9%97%AD%E4%BA%8B%E4%BB%B6%E3%80%82%2F</url>
    <content type="text"><![CDATA[在现有的ssm web系统中定义的jvm关闭钩子用于在程序关闭时关闭neo4j数据库及其相关服务，但是钩子未生效，目前原因不明，怀疑与tomcat有关，但是因为项目紧张，只能尝试先采用替代方案。 钩子代码如下： 123456789101112131415161718/** * 在jvm关闭的时候关闭图数据库 * * @param graphDb 图数据库 */ private static void registerShutdownHook(final GraphDatabaseService graphDb) &#123; Runtime.getRuntime().addShutdownHook(new Thread() &#123; @Override public void run() &#123; try &#123; graphDb.shutdown(); LogUtil.info(&quot;hook执行 在jvm关闭的时候关闭图数据库&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; 替代方案：使用spring容器启动事件和关闭事件 启动事件： 1234567891011121314151617181920212223242526/** * 启动入口数据服务 * 在系统启动时，开启定时更新neo4j数据服务 */@Service(&quot;startGateServiceListener&quot;)public class StartGateServiceListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; try &#123; /* 在web项目中（spring mvc），系统会存在两个容器，一个是root application context ,另一个就是我们自己的 projectName-servlet context（作为root application context的子容器）。 这种情况下，就会造成onApplicationEvent方法被执行两次。为了避免这个问题，我们可以只在root application context初始化完成后调用逻辑代码，其他的容器的初始化完成，则不做任何处理。*/ if (event.getApplicationContext().getParent() == null) &#123; LogUtil.info(&quot;-----------系统初始化，启动每日定时更新话单图库任务！----------&quot;); StartTimedTask.startRun(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); LogUtil.error(&quot;&quot;+e); &#125; &#125;&#125; 关闭事件： 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by admin on 2017/6/15. * spring容器关闭事件 */@Service(&quot;stopNeo4jServiceListener&quot;)public class StopNeo4jServiceListener implements ApplicationListener&lt;ContextClosedEvent&gt; &#123; @Override public void onApplicationEvent(ContextClosedEvent contextClosedEvent) &#123; System.out.println(&quot;stopNeo4jServiceListener ... run&quot;); try &#123; if(contextClosedEvent.getApplicationContext().getParent() == null) &#123; if ( StartTimedTask.scheduler != null)&#123; StartTimedTask.scheduler.shutdown(); LogUtil.info(&quot;系统关闭监听任务：关闭neo4j话单定时导入服务。&quot;); &#125; GraphDatabaseService graphDb = NeoCore.getInstance().getGraphDb(); if(graphDb != null)&#123; graphDb.shutdown(); LogUtil.info(&quot;系统关闭监听任务：关闭neo4j数据库&quot;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); LogUtil.error(&quot;&quot;+e); &#125; &#125;&#125; 20181126再补充修改，钩子其实应该是生效的，只是在关闭过程中日志打不出来，使用System.out应该可以看到执行成功了]]></content>
  </entry>
  <entry>
    <title><![CDATA[spring 配置xml文件心得]]></title>
    <url>%2F2018%2F11%2F26%2Fspring-%E9%85%8D%E7%BD%AExml%E6%96%87%E4%BB%B6%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[1、在Spring的配置里，最好不要配置xsd文件的版本号 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!-- 启用注解 –&gt; &lt;context:annotation-config /&gt; &lt;!-- 启动组件扫描，排除@Controller组件，该组件由SpringMVC配置文件扫描 –&gt; &lt;context:component-scan base-package=”com.iflytek.bdui”&gt; &lt;context:exclude-filter type=”annotation” expression=”org.springframework.stereotype.Controller” /&gt; &lt;/context:component-scan&gt; 为什么不要在Spring的配置里，配置上XSD的版本号？因为如果没有配置版本号，取的就是当前jar里的XSD文件，减少了各种风险。而且这样约定大于配置的方式很优雅。]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle项目转maven]]></title>
    <url>%2F2018%2F11%2F26%2Fgradle%E9%A1%B9%E7%9B%AE%E8%BD%ACmaven%2F</url>
    <content type="text"><![CDATA[最近与中科大合作接手了一个项目代码，是gradle工程，因公司项目构建工具都是maven，为了保持风格统一便于开发维护，需要将gradle项目转为maven. 其实配置也很简单，在build.gradle中添加如下配置 12345678910111213141516apply plugin: &apos;maven&apos;task writeNewPom &lt;&lt; &#123; pom &#123; project &#123; inceptionYear &apos;2018&apos; licenses &#123; license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; distribution &apos;repo&apos; &#125; &#125; &#125; &#125;.writeTo(&quot;pom.xml&quot;)&#125; 再运行右侧 gradle writeNewPom 即可在当前项目中生成pom.xml文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu14.10 ssh允许root用户远程登录]]></title>
    <url>%2F2018%2F11%2F26%2Fubuntu14-10-ssh%E5%85%81%E8%AE%B8root%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[修改 root 密码 sudo passwd root 以其他账户登录，通过 sudo nano 修改 /etc/ssh/sshd_config : xxx@ubuntu14:~$ su - rootPassword:root@ubuntu14:~# vi /etc/ssh/sshd_config 注释掉 #PermitRootLogin without-password，添加 PermitRootLogin ye # Authentication:LoginGraceTime 120 #PermitRootLogin without-passwordPermitRootLogin yesStrictModes yes 4. 重启 ssh 服务 root@ubuntu14:~# sudo service ssh restartssh stop/waitingssh start/running, process 1499root@ubuntu14:~#]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux不关机查看raid信息]]></title>
    <url>%2F2018%2F11%2F26%2Flinux%E6%9F%A5%E7%9C%8Braid%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[服务器做的硬件raid网上查了很久没有看到不关机可以明确看到raid的命令。 具体实践如下： 1234567891011root@ubuntu:~# df -hFilesystem Size Used Avail Use% Mounted onudev 63G 0 63G 0% /devtmpfs 13G 82M 13G 1% /run/dev/sda3 491G 190G 276G 41% /tmpfs 63G 0 63G 0% /dev/shmtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 63G 0 63G 0% /sys/fs/cgroup/dev/sdb 3.6T 1.1T 2.4T 31% /iflytek/dev/sda1 180M 56M 111M 34% /boottmpfs 13G 0 13G 0% /run/user/0 /上面可以看到可用磁盘大小约4T+； 123456789101112131415161718192021222324252627root@ubuntu:~# cat /proc/scsi/scsiAttached devices:Host: scsi0 Channel: 00 Id: 00 Lun: 00 Vendor: PM8060- Model: R1 Rev: V1.0 Type: Direct-Access ANSI SCSI revision: 02Host: scsi0 Channel: 00 Id: 01 Lun: 00 Vendor: PM8060- Model: R2 Rev: V1.0 Type: Direct-Access ANSI SCSI revision: 02Host: scsi0 Channel: 01 Id: 00 Lun: 00 Vendor: SEAGATE Model: ST600MM0208 Rev: N001 Type: Direct-Access ANSI SCSI revision: 06Host: scsi0 Channel: 01 Id: 01 Lun: 00 Vendor: SEAGATE Model: ST600MM0208 Rev: N001 Type: Direct-Access ANSI SCSI revision: 06Host: scsi0 Channel: 01 Id: 02 Lun: 00 Vendor: HGST Model: HUS726020AL5210 Rev: A907 Type: Direct-Access ANSI SCSI revision: 06Host: scsi0 Channel: 01 Id: 03 Lun: 00 Vendor: HGST Model: HUS726020AL5210 Rev: A907 Type: Direct-Access ANSI SCSI revision: 06Host: scsi0 Channel: 01 Id: 04 Lun: 00 Vendor: HGST Model: HUS726020AL5210 Rev: A907 Type: Direct-Access ANSI SCSI revision: 06Host: scsi0 Channel: 03 Id: 00 Lun: 00 Vendor: ADAPTEC Model: Virtual SGPIO Rev: 1 Type: Enclosure ANSI SCSI revision: 05root@ubuntu:~# 可以根据以上命令出现的磁盘型号去百度下具体容量信息： ST600MM0208 希捷600G 2HUS726020AL5210 日立2tb 3 综上可以看到总磁盘容量在7T以上但实际只用了4T多，肯定是做了raid]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu系统挂载新硬盘]]></title>
    <url>%2F2018%2F11%2F26%2Fubuntu%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[主要参考了网上两篇文章 1、http://blog.csdn.net/zqixiao_09/article/details/51417432 2、http://blog.csdn.net/qq_29729577/article/details/52057629 分区采用了第二篇文章的，ext4，采用uuid方式编辑/etc/fstab 1、查看硬盘信息 #fdisk -l 2、格式化分区： #mkfs.ext4 /dev/sdb1 //注：将/dev/sdb1格式化为ext4类型 3、创建/data1目录： #mkdir /data1 4、设置开机挂载 首先查看sdb所对应的UUID # ls -l /dev/disk/by-uuid/ 我的是d4d51645-d50e-4ab5-a38f-21b17b024807 # vim /etc/fstab ###自定义额外挂载的400g硬盘 /dev/sdc 到/iflytek目录UUID=d4d51645-d50e-4ab5-a38f-21b17b024807 /data1 ext4 defaults 0 2 1234567891011121314151617181920# /etc/fstab: static file system information.## Use &apos;blkid&apos; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# / was on /dev/sda1 during installationUUID=603e545c-77b3-4f2e-aa06-58361e1b43e5 / ext4 errors=remount-ro 0 1# /home was on /dev/sda6 during installationUUID=25bb41a3-0d63-4c5a-81ff-564a44e53006 /home ext4 defaults 0 2# /var was on /dev/sda2 during installationUUID=2a8b44eb-8e16-4226-897f-5f89bc567dcd /var ext4 defaults 0 2# swap was on /dev/sda5 during installationUUID=7b75db6c-057d-4063-b0e8-1116a97e3ef8 none swap sw 0 0# /home/iflytek/data was on /dev/sdb1 during config...UUID=704a3761-7f0e-4c34-9d37-fabd4150a488 /home/iflytek/data ext4 defaults 0 2#自定义额外挂载的400g硬盘 /dev/sdc 到/iflytek目录UUID=d4d51645-d50e-4ab5-a38f-21b17b024807 /data1 ext4 defaults 0 2]]></content>
  </entry>
  <entry>
    <title><![CDATA[ETL数据抽取转换工具DataX使用记录]]></title>
    <url>%2F2018%2F11%2F26%2FETL%E6%95%B0%E6%8D%AE%E6%8A%BD%E5%8F%96%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7DataX%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[DataX是一个在异构的[数据库](http://lib.csdn.net/base/mysql)/文件系统之间高速交换数据的工具，实现了在任意的数据处理系统(RDBMS/Hdfs/Local filesystem）之间的数据交换 datax产品说明http://code.taobao.org/p/datax/wiki/DataX%E4%BA%A7%E5%93%81%E8%AF%B4%E6%98%8E/ 从oracle读取数据打印到控制台1234567//启动脚本#!/bin/bashsource ~/.bashrcpython /home/hadoop/ceshi/datax/bin/datax.py /home/hadoop/test/jobJson/test2.json 12345678910111213141516171819202122232425262728293031323334353637383940//任务json&#123; &quot;job&quot;: &#123; &quot;setting&quot;: &#123; &quot;speed&quot;: &#123; &quot;channel&quot;: 5 &#125; &#125;, &quot;content&quot;: [ &#123; &quot;reader&quot;: &#123; &quot;name&quot;: &quot;oraclereader&quot;, &quot;parameter&quot;: &#123; &quot;username&quot;: &quot;****&quot;, &quot;password&quot;: &quot;****&quot;, &quot;where&quot;: &quot;&quot;, &quot;connection&quot;: [ &#123; &quot;querySql&quot;: [ &quot;select callingtel,calledtel from trecord where calledtel &lt;= 100 group by callingtel,calledtel&quot; ], &quot;jdbcUrl&quot;: [ &quot;jdbc:oracle:thin:@192.168.140.30:1521:TEST&quot; ] &#125; ] &#125; &#125;, &quot;writer&quot;: &#123; &quot;name&quot;: &quot;streamwriter&quot;, &quot;parameter&quot;: &#123; &quot;visible&quot;: true, &quot;encoding&quot;: &quot;UTF-8&quot; &#125; &#125; &#125; ] &#125;&#125; 从oracle导出数据到csv文件（用于neo4j数据导入）1234567891011121314151617181920212223242526272829303132333435363738394041//任务json; 启动命令与以上类似 【需要注意channel的不同？】&#123; &quot;job&quot;: &#123; &quot;content&quot;: [ &#123; &quot;reader&quot;: &#123; &quot;name&quot;: &quot;oraclereader&quot;, &quot;parameter&quot;: &#123; &quot;connection&quot;: [ &#123; &quot;querySql&quot;: [ &quot;SELECT CALLINGTEL AS START_ID, (CASE DATATYPE WHEN 0 THEN &apos;voice&apos;WHEN 3 THEN &apos;sms&apos;ELSE &apos;&apos;END ) calltype, (BEGINTIME - TO_DATE (&apos;1970-01-01&apos;, &apos;yyyy-mm-dd&apos;) ) * 24 * 60 * 60 * 1000 AS BeginTime, ((BEGINTIME - TO_DATE (&apos;1970-01-01&apos;, &apos;yyyy-mm-dd&apos;) ) * 24 * 60 * 60 * 1000 ) + (SPAN * 1000) AS EndTime, SPAN AS Span, CALLEDTEL AS END_ID, (CASE DATATYPE WHEN 0 THEN &apos;voice&apos;WHEN 3 THEN &apos;sms&apos;ELSE &apos;&apos;END ) TYPE FROM TRECORD WHERE CALLINGTEL != CALLEDTEL AND CALLINGTEL IS NOT NULL AND CALLEDTEL IS NOT NULL&quot;], &quot;jdbcUrl&quot;: [ &quot;jdbc:oracle:thin:@10.1.140.30:1521:TEST&quot; ] &#125; ], &quot;password&quot;: &quot;test&quot;, &quot;username&quot;: &quot;test&quot; &#125; &#125;, &quot;writer&quot;: &#123; &quot;name&quot;: &quot;txtfilewriter&quot;, &quot;parameter&quot;: &#123; &quot;path&quot;: &quot;/home/hadoop/test/data/&quot;, &quot;fileName&quot;: &quot;rel&quot;, &quot;fileType&quot;: &quot;csv&quot;, &quot;fieldDelimiter&quot;: &quot;,&quot;, &quot;writeMode&quot;: &quot;append&quot; &#125; &#125; &#125; ], &quot;setting&quot;: &#123; &quot;speed&quot;: &#123; &quot;channel&quot;: &quot;10&quot; &#125; &#125; &#125;&#125; fz用oracle导出数据到hdfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//querySql模式，parameter-column可以不用指定&#123; &quot;job&quot;: &#123; &quot;content&quot;: [ &#123; &quot;reader&quot;: &#123; &quot;name&quot;: &quot;oraclereader&quot;, &quot;parameter&quot;: &#123; &quot;connection&quot;: [ &#123; &quot;querySql&quot;: [ &quot;select callingtel,calledtel from trecord where to_char(rectime,&apos;yyyy-mm-dd&apos;)=to_char(sysdate - 1,&apos;yyyy-mm-dd&apos;) group by callingtel,calledtel&quot; ], &quot;jdbcUrl&quot;: [ &quot;jdbc:oracle:thin:@192.168.140.30:1521:TEST&quot; ] &#125; ], &quot;password&quot;: &quot;****&quot;, &quot;username&quot;: &quot;****&quot; &#125; &#125;, &quot;writer&quot;: &#123; &quot;name&quot;: &quot;hdfswriter&quot;, &quot;parameter&quot;: &#123; &quot;column&quot;: [ &#123; &quot;name&quot;: &quot;callingtel&quot;, &quot;type&quot;: &quot;INT&quot; &#125;, &#123; &quot;name&quot;: &quot;calledtel&quot;, &quot;type&quot;: &quot;INT&quot; &#125; ], &quot;compress&quot;: &quot;&quot;, &quot;defaultFS&quot;: &quot;hdfs://192.168.140.11:9000&quot;, &quot;fieldDelimiter&quot;: &quot; &quot;, &quot;fileName&quot;: &quot;trecord&quot;, &quot;fileType&quot;: &quot;text&quot;, &quot;path&quot;: &quot;/user/test/data/&quot;, &quot;writeMode&quot;: &quot;append&quot; &#125; &#125; &#125; ], &quot;setting&quot;: &#123; &quot;speed&quot;: &#123; &quot;channel&quot;: &quot;2&quot; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu server设置开启程序自启动]]></title>
    <url>%2F2018%2F11%2F26%2Fubuntu-server%E8%AE%BE%E7%BD%AE%E5%BC%80%E5%90%AF%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在项目中经常遇到需要服务器开机自启动相关程序的情况，下面以一个neo4j数据库和spring boot web程序为例撰写了一个demo 编写一个启动所有程序的脚本注意有些程序有前后依赖关系可以sleep几秒等一下 Ubuntu下添加开机启动脚本 # vim /etc/rc.local #配置启动执行的log日志，方便调试，错误查看 exec 1&gt;/tmp/rc.local.log 2&gt;&amp;1 # send stdout and stderr from rc.local to a log file set -x # tell sh to display commands before execution #rc.local中识别不到java，需要配置jdk环境变量 export JAVA_HOME=/opt/java/jdk1.8.0_102 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:${PATH} # 最后执行编写好的启动脚本即可 /iflytek/bin/startAllService.sh exit 0 Ubuntu开机之后会执行/etc/rc.local文件中的脚本，所以我们可以直接在/etc/rc.local中添加启动脚本。当然要添加到语句：exit 0 前面才行。 重启测试即可]]></content>
      <categories>
        <category>常用技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux部署JDK8]]></title>
    <url>%2F2018%2F11%2F26%2Flinux%E9%83%A8%E7%BD%B2JDK8%2F</url>
    <content type="text"><![CDATA[经常会遇到linux服务器需要部署JDK8的情况，每次都是临时百度或者翻文档，索性不如花几分钟整理成博客，为以后方便也可以分享给大家。 （以jdk-8u102-linux-x64.tar.gz为例） 1 安装以root用户登录 # mkdir /opt/java # tar -zxvf jdk-8u102-linux-x64.tar.gz -C /opt/java # chown -R root:root /opt/java 2 配置环境变量切换到需要安装jdk的用户（以es为例） # su iflytek $ vim ~/.bashrc （在文件最后添加如下内容） export JAVA_HOME=/opt/java/jdk1.8.0_102 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:${PATH} 执行文件使其生效 $ source ~/.bashrc 3 验证验证jdk是否安装成功 $ java -version 出现下图则安装成功]]></content>
      <categories>
        <category>常用技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用github+hexo搭建自己的个人博客]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%B5%8B%E8%AF%95%E6%96%B0%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前提不再赘述： 1、有github账户 2、安装node js 3、本地安装了git （安装后进行config –global初始配置，包括创建上传ssh key到github账户） 正式开始： 1、先进入本地与github关联的仓库目录下，我的是 /f/git_repository/，新建 myBlog目录 打开git bash命令工具 cd /f/git_repository/myBlog 2、初始化 $ hexo init 3、生成静态页面 初始化完成之后，就已经生成一篇“hello word”的文章了，现在执行以下命令把文章编译为静态页面： $ hexo generate 4、本地启动 把文章变为页面之后，可以执行以下命令，本地启动服务，在浏览器中输入http://localhost:4000/查看生成的页面效果 hexo server 这时开始出现了问题执行命令hexo server，提示：Usage: hexo …. 提示找不到该server指令 解决方法，在Hexo 3.0 后server被单独出来了，需要安装server，安装此server后再试，问题解决。安装的命令如下（我用git bash执行报错了，切换到win cmd执行成功）： npm install hexo-server –save 4、重新编译启动，执行：hexo server，启动了服务，在浏览器输入本地地址访问，看到白板和Cannot GET / 几个字 1234567在Hexo博客中，出现Cannot GET/xxx错误便意味着xxx文件未被找到。Cannot GET/xxx错误本质是hexo server返回的一个404错误。开始查找原因 网上说是由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：npm install hexo-renderer-ejs--savenpm install hexo-renderer-stylus--savenpm install hexo-renderer-marked--save 三条命令执行完这时候重新启动本地服务再访问还是不行 因此，继续排查方式如下： 1.判断public目录下xxx文件是否存在。 （我的错误是 Cannot GET /，因此在public目录下寻找index.html是否存在。） 2.如果说index.html不存在，那么执行hexo c，hexo g重新生成一次，回到步骤1。 3.步骤2执行完后index.html仍不存在，执行npm audit fix，查看是否少了什么组件，通过npm install hexo-xxx-xxx 安装即可。 $ npm audit fix （我的hexo缺少了hexo-generator-archive等组件，因此执行npm install hexo-generator-archive …即可）。 npm install hexo-generator-archive 4.步骤3完成之后，执行hexo clean，hexo g重新生成静态文件。 5、再次启动 hexo server 访问http://localhost:4000/ 终于成功，显示的是一个默认界面 自定义美化 1、切换主题 1234567admin@zhensun2 MINGW64 /f/git_repository/myBlog$ git clone https://github.com/iissnan/hexo-theme-next.git themes/nextCloning into &apos;themes/next&apos;...remote: Enumerating objects: 12033, done.remote: Total 12033 (delta 0), reused 0 (delta 0), pack-reused 12033Receiving objects: 100% (12033/12033), 12.95 MiB | 547.00 KiB/s, done.Resolving deltas: 100% (6966/6966), done. 2、切换主题后进行一些自定义美化设置 3、利用hexo-admin工具进行管理、发布文章等 1$ npm install --save hexo-admin 最终部署 部署到github前需要修改根目录_config.yml，不然会出现访问github pages网页只有文字没有样式的情况 具体可以参考这个文章 [hexo + github pages搭建博客样式加载不出来](https://blog.csdn.net/banjw_129/article/details/82261165) 添加评论组件 评论组件选用了韩国的来比力，详情参考了这篇文章： [Hexo-NexT主题添加评论功能（来必力、Hypercomments、畅言、友言）](https://blog.csdn.net/qq_32454537/article/details/79482879)]]></content>
      <categories>
        <category>常用技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
